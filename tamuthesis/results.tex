%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  New template code for TAMU Theses and Dissertations starting Fall 2012.
%  For more info about this template or the
%  TAMU LaTeX User's Group, see http://www.howdy.me/.
%
%  Author: Wendy Lynn Turner
%	 Version 1.0
%  Last updated 8/5/2012
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           SECTION III
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{\uppercase{Results and Conclusions}}

Each language had its advantages and disadvantages to the ray tracing process.  These were further accentuated by the speed tests conducted for each Milestone.  The results of each speed test were not surprising based on previous knowledge of each language's strengths and weaknesses.  

Python was the slowest and C++ was the fastest; Processing was faster than Python yet still held a significant difference from C++ in large computing milestones.  The speed difference between Processing and C++ is less than expected, since C++ is compiled before running the test and Processing's speed test is considered with the Processing ``play'' button, which presumedly compiles and runs the code all at once.

\section{Conclusions}
Each language will be discussed with its pros and cons. A recommendation as to the most suitable language for maximizing focus on the implementation theory as opposed to the implementation process of writing code syntax will also be made. It is essential however, it is essential to learn a baseline of scripting and coding concepts; the language syntax and compilation processes cannot be avoided.  For instance, in order to call a function associated with a class, the class must first be initiated. After which, call the function as part of that class, as follows:

\singlespacing
\begin{lstlisting}[language=C++, caption=C++ Class usage example, style=mystyle, label=list:c++Use]
Sphere sphere_object = new Sphere();
bool is_hit = sphere_object.intersect(ray_object);
\end{lstlisting}
\doublespacing

I expected some programming concepts to be easier in some languages.  For instance computing procedural images from recursive math equations was very difficult for me to grasp within C++.  Implementing this was no easier in Processing or Python, emphasizing that as natural or user-friendly a language's syntax might claim to be, if the underlying concepts are not fully understood, it makes no difference.  

\subsection{C++}
C++ is the fastest processor of all the languages tested.  Its speed allowed for quicker iterations and more creative freedom with the final images.  C++ processed the scale of computation for large images far more quickly than either Java or Python.  On the downside, C++ is not an easy language to learn; there was much more overhead to learn in order to compile and set up a C++ project.  Whereas other languages allow for the simplicity of simply creating an executable file and running, C++ had a variety of compilers to choose from, followed by a multitude of files and commands needing to be run before the image would appear on the screen.  This could be automated to save time, but the initial process is not intuitive enough to a new programmer.  I assert that the knowledge gained from writing the first ray tracer in C++ allowed (or enabled faster) for faster implementation of the subsequent ray tracers. Any artist who would like a complete understanding of how programming works from the bare-bones of computer design should challenge themselves and implement in C++.  Since C++ is a low-level language which exposed the basic process of how a computer handles the execution of a program with it's ``make'' functionality, which helped me to understand how the computer was processing and failing on different part of the process.  That being said, most artists will be writing only one ray tracer, so the knowledge of how to compile and run the program still needs to be gained, but this can be accomplished with languages that are more intuitive and forgiving than with C++.

\subsection{Processing}
Processing was the easiest language to compile and execute code.  Processing has expedited the execution process by packaging the code compiler within its own custom ``IDE'' (The language Processing for this thesis encompasses both the java language and the Processing executable that is delivered with a download).  While Processing comes with all the libraries necessary to implement a ray tracer, using them introduces another challenge.  Addition in this language with the supplied Vector form was done through a function(Vector.add()) rather than through an operator (such as plus ``+'' or minus ``-'').  While unnatural for complex math functions, overall, this was a small setback in creating a raytracer.  The benefits of an expedited compilation process outweighs the initial difficulty of navigating language syntax.  In addition, error handling in Processing is more informative, and will bring directly you to the section of the code where the error occurred within the IDE.  This is a benefit of using the Processing IDE as a part of the Processing language, over Python or C++.

\subsection{Python}
Python was the slowest of all the languages.  It was, however, the easiest to write code in.  By design, Python strives to have the most instinctive syntax of all the languages.  While there are still rules to follow when creating Python code, Python contains far less than C++ or in Processing.  Python, however, still needed the use of include statements, which can be a difficult concept to grasp when writing large programs. Since Java and C++ are both statically typed, they need more strict rules as to when variables can be set and what those variables can be set to.  A lot of time was spent learning and understanding polymorphism and sub-typing for Java and C++ so that each ray tracer can more closely mimic the ray tracing theory.  With Python, this time-consuming research was unnecessary when implementing these complex data structures.

Python was significantly slower than both C++ and Processing.  While Pixar or Dreamworks will not be using Python for the next iteration of their ray tracer,the slowness was inconsequential for learning ray tracing theory.  Speed being its biggest impediment, strategies could be implemented to allow for a speedier artistic development process.  The most useful time-saving work-flow strategy involved developing a lower resolution ``layout'' image which was used to prepare a final render, as opposed to rendering the full resolution for every iteration.  For single frame rendering, five minutes is not a long time to wait for the final product, but when iterating to get the perfect composition, 5 minutes a frame can add up over 50-100 iterations.  To iterate over artistic versions of a rendered image, a lower resolution image that only takes 30 seconds preferable.  The final image only needs to be the final resolution, which theoretically should only take five minutes once.

\section{Final Recommendation}
For every language, you need to learn computer science terms like classes and recursion.  This is beneficial to the overall process and cannot be avoided.  In addition, it is understood that in each language there is a necessary evil of learning some sort of syntax-related information.  Every language has its own quirks, and these quirks establish the difficulty level in using each language.  Time needed to learn each language to process syntax and data types was relatively equal for each language.  Therefore, the deciding factor that this recommendation is based on is the setup overheard that is required to learn before any code is written.  

Processing is the best recommendation considering it's limited-to-no overhead.  While Processing has some counterintuitive syntax, learning that syntax takes no more time than learning the syntax of C++ or Python, and and takes less time to learn than the total time it took to learn how to set up the Python and C++ environments.  With C++ you must understand make files and header files in addition to establishing a workflow to successfully execute the written code, but Processing has packaged all this overhead into a simple IDE that ``makes" and executes autonomously.  Processing's compilation times were not as slow as Python, and compared to C++ the times do not discredit the language from quick, interactive artistic repetition to achieve the best results.  Processing was initially created ``to teach computer programming fundamentals within a visual context" and after testing the different languages, Processing was the language with the least overhead to implementation benefit ratio and is highly recommended for artists wishing to introduce themselves to complex programming problems.  